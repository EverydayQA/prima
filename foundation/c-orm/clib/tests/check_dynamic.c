
// This is the C half of the proof-of-concept for C-ORM.  It shows how an ORM
// library can be constructed on top of the basis libraries here, and how that
// can be used to populate a struct from the database.
// 
// The other half of the proof-of-concept is the Python code that can 
// auto-generate the code below, given only the C header file containing the
// struct.
//
// This file is in two parts.  First, the code that would be auto-generated
// by Python.  Then a short test that calls that code to extract values
// from the database.

#include <stdio.h>
#include <check.h>

#include "isti.h"
#include "isti_flow.h"
#include "isti_sql.h"
#include "isti_sqlite.h"

// This is the file that defines the `struct`, which is typedefed as `foo`.
// This same file can be used as input to the Python library to auto-generate
// the mapper code and structs below.
#include "foo.h"

// Import the libraries that we will use.  All libraries are "namespaced" as
// structs to reduce the chance of name collisions.
ISTI_SQL_AS(sql)
ISTI_SQLITE_AS(sqlite)

// ## Auto-generated by Python
//
// When fully implemented, code in this section would be generated by Python
// code (that code already exists in an almost-complete state - see the
// Python docs).

// The callback that populates the struct.  This is called by the loading code
// when values are read from the database.
//
// We need a custom callback so that the types are handled correctly - there
// is no way (that I can see) to do this with generic code.  But since this
// is auto-generated by the Python helper this is not a problem.
static int load_foo(void *v, size_t n, char type, void *value) {
  foo *f = (foo *)v;
  switch (n) {
  case 0: f->id = *(int *)value; break;
  case 1: f->bar = *(int *)value; break;
  case 2: f->baz = (char *)value; break;
  default: return -1;
  }
  return 0;
}

// These two structs work together to give the API for searching the database.
// We need two structs so that we can have separate namespaces for the fields
// and the ORM commands (so the "where" and "and" in the API actually serve
// a purpose, in that they switch namespaces - a field named "one" would
// otherwise conflict with the ORM API function `one()` that retrieves an
// instance of the struct.
struct foo_param;
struct foo_mapper;

// The API.  Again, all this would be auto-generated by the Python script.
typedef int (foo_one_t)(struct foo_mapper *, foo **f);

typedef struct foo_mapper *(foo_id_t)(struct foo_mapper *, int id);
typedef struct foo_mapper *(foo_bar_t)(struct foo_mapper *, int bar);
typedef struct foo_mapper *(foo_baz_t)(struct foo_mapper *, char *baz);

// The namespace for fields.  See how each field in the database/struct
// corresponds to a *typed* function.  This is a big advantage over the
// lower level libraries, which use generic pointers.
typedef struct foo_param {
  foo_id_t *id;
  foo_bar_t *bar;
  foo_baz_t *baz;
} foo_param;

// Implementation details that would not be exposed via the public header
// file.  This is where the API accumulates the SQL needed.
typedef struct foo_internal {
  isti_db *db;
  isti_sql *sql;
  int n_params;
  foo_param param;
  int status;
} foo_internal;

// The namespace for the ORM API.  Members like `where` and `and` switch to
// the field namespace, `foo_param`, described above.
typedef struct foo_mapper {
  foo_param *where;
  foo_param *and;
  foo_one_t *one;
  foo_internal internal;
} foo_mapper;

// A helper function that appends either "where" or "and" to the SQL being
// constructed (depending on whether or not we are adding the first 
// condition).
static int and_where(foo_mapper *m) {
  STATUS;
  if (m->internal.n_params++) {
    CHECK(sql.append(m->internal.sql, " and"));
  } else {
    CHECK(sql.append(m->internal.sql, " where"));
  }
  EXIT_STATUS;
}

// The individual functions for handling each field in the struct follow.
// All that is important here is to see how they are simple enough to be
// auto-generated by a fairly dumb template in the Python code.

static foo_mapper *foo_param_id(foo_mapper *m, int id) {
  STATUS;
  CHECK(m->internal.status);
  CHECK(and_where(m));
  CHECK(sql.appendf(m->internal.sql, " id=%d", id));
  EXIT;
  m->internal.status = status;
  return m;
}

static foo_mapper *foo_param_bar(foo_mapper *m, int bar) {
  STATUS;
  CHECK(m->internal.status);
  CHECK(and_where(m));
  CHECK(sql.appendf(m->internal.sql, " bar=%d", bar));
  EXIT;
  m->internal.status = status;
  return m;
}

static foo_mapper *foo_param_baz(foo_mapper *m, char *baz) {
  STATUS;
  CHECK(m->internal.status);
  CHECK(and_where(m));
  CHECK(sql.appendf(m->internal.sql, " baz=%s", baz));
  EXIT;
  m->internal.status = status;
  return m;
}

static int foo_one(foo_mapper *m, foo **f) {
  STATUS;
  CHECK(m->internal.status);
  isti_db *db = m->internal.db;
  CHECK(db->sql_one(db, m->internal.sql, "dds", load_foo, f));
  EXIT;
  free(m);
  return status;
}

// Put everything together to construct the API.
static int map_foo(isti_db *db, foo_mapper **m) {
  STATUS;
  ASSERT_MEM(*m = calloc(1, sizeof(**m)));
  (*m)->internal.db = db;
  CHECK(sql.sql(&(*m)->internal.sql, "select id, bar, baz from foo"));
  (*m)->internal.param.id = foo_param_id;
  (*m)->internal.param.bar = foo_param_bar;
  (*m)->internal.param.baz = foo_param_baz;
  (*m)->internal.status = ISTI_OK;
  (*m)->where = &(*m)->internal.param;
  (*m)->and = &(*m)->internal.param;
  (*m)->one = foo_one;
  EXIT_STATUS;
}

// ## Test the above
//
// Given the (eventually auto-generated) library above, we can now test the
// functionality.

START_TEST(test_read)
{

  // Obtain a connection to the database.  This uses an SQLite database, but
  // the handle returned is a generic API.
  isti_db *db = NULL;
  fail_if(sqlite.open(&db, "check_isti_sqlite.db", 60),
          "Could not connect to database");

  // Construct a mapper.  This does the work of extracting a value from the
  // database.
  foo_mapper *m;
  fail_if(map_foo(db, &m), "Could not get mapper");

  // **Call the mapper, filtering the database entries, and extracting a
  // single instance of the `foo` struct.**
  foo *f;
  fail_if(m->where->bar(m, 42)->and->baz(m, "towel")->one(m, &f),
          "Could not retrieve foo");
}
END_TEST

// Everything below is boilerplate for the tests.

Suite* sqlite_suite (void) {
  Suite *suite = suite_create("dynamic");
  TCase *tcase = tcase_create("case");
  tcase_add_test(tcase, test_read);
  suite_add_tcase(suite, tcase);
  return suite;
}

int main (int argc, char *argv[]) {
  int number_failed;
  Suite *suite = sqlite_suite();
  SRunner *runner = srunner_create(suite);
  srunner_set_xml(runner, "check-dynamic.xml");
  srunner_run_all(runner, CK_NORMAL);
  number_failed = srunner_ntests_failed(runner);
  srunner_free(runner);
  return number_failed;
}
